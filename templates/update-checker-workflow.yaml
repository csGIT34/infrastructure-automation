# Infrastructure Pattern Update Checker
# Copy this file to your repository: .github/workflows/infra-update-check.yaml
#
# This workflow checks for new versions of infrastructure patterns
# and creates PRs to update your infrastructure.yaml file.
#
# Similar to Dependabot for infrastructure patterns.
#
# Configuration:
#   Set the schedule below (default: weekly on Mondays)
#   Set the infrastructure repo if different from default

name: Infrastructure Update Check

on:
  # Run on schedule (weekly by default)
  schedule:
    - cron: '0 9 * * 1'  # Every Monday at 9 AM UTC

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (show updates but do not create PR)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pull-requests: write

env:
  # Infrastructure platform repository
  INFRA_REPO: csGIT34/infrastructure-automation

jobs:
  check-updates:
    runs-on: ubuntu-latest
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      update_summary: ${{ steps.check.outputs.update_summary }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml requests

      - name: Check for pattern updates
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import os
          import subprocess
          import re
          from datetime import datetime

          INFRA_FILE = "infrastructure.yaml"
          INFRA_REPO = os.environ.get("INFRA_REPO", "csGIT34/infrastructure-automation")

          def get_latest_version(pattern):
              """Get the latest release version for a pattern."""
              try:
                  result = subprocess.run(
                      ['gh', 'release', 'list',
                       '--repo', INFRA_REPO,
                       '--json', 'tagName,publishedAt,name,isPrerelease',
                       '--limit', '50'],
                      capture_output=True,
                      text=True,
                      timeout=30
                  )
                  if result.returncode != 0:
                      print(f"Warning: Could not list releases: {result.stderr}")
                      return None, None

                  releases = json.loads(result.stdout)

                  # Find releases for this pattern
                  pattern_releases = []
                  for r in releases:
                      tag = r.get('tagName', '')
                      # Match pattern/vX.Y.Z format
                      match = re.match(rf'^{re.escape(pattern)}/v(\d+\.\d+\.\d+)$', tag)
                      if match and not r.get('isPrerelease', False):
                          version = match.group(1)
                          pattern_releases.append({
                              'version': version,
                              'tag': tag,
                              'published': r.get('publishedAt', ''),
                              'name': r.get('name', tag)
                          })

                  if not pattern_releases:
                      return None, None

                  # Sort by version (semver)
                  def version_key(v):
                      parts = v['version'].split('.')
                      return tuple(int(p) for p in parts)

                  pattern_releases.sort(key=version_key, reverse=True)
                  latest = pattern_releases[0]
                  return latest['version'], latest['tag']

              except Exception as e:
                  print(f"Warning: Error getting latest version for {pattern}: {e}")
                  return None, None

          def get_changelog(pattern, from_version, to_version):
              """Get changelog between two versions."""
              try:
                  from_tag = f"{pattern}/v{from_version}"
                  to_tag = f"{pattern}/v{to_version}"

                  result = subprocess.run(
                      ['gh', 'release', 'view', to_tag,
                       '--repo', INFRA_REPO,
                       '--json', 'body'],
                      capture_output=True,
                      text=True,
                      timeout=30
                  )
                  if result.returncode == 0:
                      data = json.loads(result.stdout)
                      return data.get('body', '')
              except Exception as e:
                  print(f"Warning: Could not get changelog: {e}")
              return ''

          def version_compare(v1, v2):
              """Compare two versions. Returns: -1 if v1<v2, 0 if v1==v2, 1 if v1>v2."""
              parts1 = [int(p) for p in v1.split('.')]
              parts2 = [int(p) for p in v2.split('.')]
              for p1, p2 in zip(parts1, parts2):
                  if p1 < p2:
                      return -1
                  if p1 > p2:
                      return 1
              return 0

          def get_version_bump_type(from_v, to_v):
              """Determine if this is a major, minor, or patch bump."""
              from_parts = [int(p) for p in from_v.split('.')]
              to_parts = [int(p) for p in to_v.split('.')]

              if to_parts[0] > from_parts[0]:
                  return 'major'
              elif to_parts[1] > from_parts[1]:
                  return 'minor'
              else:
                  return 'patch'

          # Check if infrastructure.yaml exists
          if not os.path.exists(INFRA_FILE):
              print("No infrastructure.yaml found")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("has_updates=false\n")
              exit(0)

          # Parse infrastructure.yaml
          try:
              with open(INFRA_FILE, 'r') as f:
                  documents = list(yaml.safe_load_all(f))
                  documents = [d for d in documents if d is not None]
          except Exception as e:
              print(f"Error parsing infrastructure.yaml: {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("has_updates=false\n")
              exit(0)

          if not documents:
              print("No documents in infrastructure.yaml")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("has_updates=false\n")
              exit(0)

          # Check each pattern for updates
          updates = []
          for i, doc in enumerate(documents):
              if doc.get('action') == 'destroy':
                  continue  # Skip destroy actions

              pattern = doc.get('pattern', '')
              current_version = doc.get('pattern_version', '')

              if not pattern or not current_version:
                  continue

              latest_version, latest_tag = get_latest_version(pattern)

              if not latest_version:
                  print(f"Could not determine latest version for {pattern}")
                  continue

              if version_compare(current_version, latest_version) < 0:
                  bump_type = get_version_bump_type(current_version, latest_version)
                  changelog = get_changelog(pattern, current_version, latest_version)

                  updates.append({
                      'doc_index': i,
                      'pattern': pattern,
                      'current_version': current_version,
                      'latest_version': latest_version,
                      'bump_type': bump_type,
                      'changelog': changelog
                  })
                  print(f"Update available: {pattern} {current_version} -> {latest_version} ({bump_type})")

          # Output results
          has_updates = len(updates) > 0

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"has_updates={'true' if has_updates else 'false'}\n")

          # Save updates for later steps
          with open('updates.json', 'w') as f:
              json.dump(updates, f, indent=2)

          # Generate summary
          if updates:
              summary = f"Found {len(updates)} pattern update(s):\n"
              for u in updates:
                  summary += f"- {u['pattern']}: {u['current_version']} -> {u['latest_version']} ({u['bump_type']})\n"
              print(summary)

              # Also write summary to output (escaped for multiline)
              summary_escaped = summary.replace('\n', '%0A')
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"update_summary={summary_escaped}\n")
          else:
              print("All patterns are up to date!")
          EOF

      - name: Upload updates artifact
        if: steps.check.outputs.has_updates == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: updates
          path: updates.json
          retention-days: 1

  create-update-pr:
    needs: check-updates
    runs-on: ubuntu-latest
    if: needs.check-updates.outputs.has_updates == 'true' && github.event.inputs.dry_run != 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download updates artifact
        uses: actions/download-artifact@v4
        with:
          name: updates

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Apply updates to infrastructure.yaml
        id: apply
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import re

          INFRA_FILE = "infrastructure.yaml"

          # Load updates
          with open('updates.json', 'r') as f:
              updates = json.load(f)

          if not updates:
              print("No updates to apply")
              exit(0)

          # Read original file
          with open(INFRA_FILE, 'r') as f:
              content = f.read()

          # Build update map
          update_map = {u['pattern']: u for u in updates}

          # Parse YAML to get document boundaries
          # We'll use regex to update versions in place to preserve formatting
          for pattern, update in update_map.items():
              old_version = update['current_version']
              new_version = update['latest_version']

              # Match pattern_version after the pattern name
              # This handles various YAML formats
              pattern_regex = rf'(pattern:\s*{re.escape(pattern)}\s*\n(?:.*\n)*?pattern_version:\s*["\']?){re.escape(old_version)}(["\']?)'

              # First try with the pattern nearby
              if re.search(pattern_regex, content, re.MULTILINE):
                  content = re.sub(pattern_regex, rf'\g<1>{new_version}\g<2>', content, count=1)
                  print(f"Updated {pattern} from {old_version} to {new_version}")
              else:
                  # Fallback: just replace the version string if it appears once per pattern
                  simple_regex = rf'(pattern_version:\s*["\']?){re.escape(old_version)}(["\']?)'
                  content = re.sub(simple_regex, rf'\g<1>{new_version}\g<2>', content, count=1)
                  print(f"Updated {pattern} from {old_version} to {new_version} (fallback)")

          # Write updated file
          with open(INFRA_FILE, 'w') as f:
              f.write(content)

          print("Updates applied successfully")
          EOF

      - name: Generate PR body
        id: pr-body
        run: |
          python3 << 'EOF'
          import json
          import os

          with open('updates.json', 'r') as f:
              updates = json.load(f)

          body = "## Update Infrastructure Patterns\n\n"
          body += "This PR updates the following pattern versions:\n\n"
          body += "| Pattern | Current | Latest | Change Type |\n"
          body += "|---------|---------|--------|-------------|\n"

          for u in updates:
              bump_icon = "ðŸ”´" if u['bump_type'] == 'major' else ("ðŸŸ¡" if u['bump_type'] == 'minor' else "ðŸŸ¢")
              body += f"| {u['pattern']} | {u['current_version']} | {u['latest_version']} | {bump_icon} {u['bump_type'].title()} |\n"

          body += "\n### Changelog\n\n"

          for u in updates:
              body += f"#### {u['pattern']} {u['current_version']} -> {u['latest_version']}\n\n"
              if u.get('changelog'):
                  body += u['changelog'] + "\n\n"
              else:
                  body += "_No changelog available_\n\n"

          # Add breaking changes warning if any major updates
          major_updates = [u for u in updates if u['bump_type'] == 'major']
          if major_updates:
              body += "### Breaking Changes\n\n"
              body += "> **Warning:** This PR includes major version updates. "
              body += "Please review the changelog carefully for breaking changes.\n\n"
              for u in major_updates:
                  body += f"- `{u['pattern']}` has a major version update\n"
              body += "\n"

          body += "---\n"
          body += "_Auto-generated by Infrastructure Update Checker_\n"

          # Write PR body to file
          with open('pr_body.md', 'w') as f:
              f.write(body)

          print(body)
          EOF

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore(infra): update pattern versions"
          title: "Update Infrastructure Pattern Versions"
          body-path: pr_body.md
          branch: infra-pattern-updates
          delete-branch: true
          labels: |
            infrastructure
            dependencies

  summary:
    needs: [check-updates, create-update-pr]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Create summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## Infrastructure Update Check

          ### Results
          EOF

          if [ "${{ needs.check-updates.outputs.has_updates }}" == "true" ]; then
            echo "Updates found! See the created PR for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "${{ needs.check-updates.outputs.update_summary }}" | sed 's/%0A/\n/g' >> $GITHUB_STEP_SUMMARY
          else
            echo "All patterns are up to date." >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Note:** This was a dry run. No PR was created." >> $GITHUB_STEP_SUMMARY
          fi
