# Infrastructure GitOps Workflow Template
# Copy this file to your repository: .github/workflows/infrastructure.yaml
#
# Required secrets:
#   INFRA_APP_ID - GitHub App ID for Infrastructure Dispatch app
#   INFRA_APP_PRIVATE_KEY - GitHub App private key (PEM format)
#
# Supports pattern-based requests with t-shirt sizing (small/medium/large)
# Supports multi-document YAML with action field (create/destroy)
# Supports version pinning with pattern_version field
#
# Usage:
# 1. Create infrastructure.yaml in your repo root (single or multi-document)
# 2. Create a PR to see the plan preview
# 3. Merge to main to provision resources
#
# Version pinning:
#   Each pattern request must include a pattern_version field:
#   pattern: keyvault
#   pattern_version: "1.2.0"
#
# Multi-document format:
#   Use YAML document separators (---) to define multiple patterns
#   Each document can have action: create (default) or action: destroy
#   Destroy actions are executed first, then create actions
#
# Branch Protection (Recommended):
#   To require validation before merging, configure branch protection:
#   1. Go to Settings > Branches > Add branch protection rule
#   2. Branch name pattern: main
#   3. Enable "Require status checks to pass before merging"
#   4. Search for and select: "Infrastructure GitOps / validate-and-plan"
#   5. Save changes
#
#   This ensures invalid infrastructure.yaml files cannot be merged.

name: Infrastructure GitOps

on:
  push:
    branches:
      - main
    paths:
      - 'infrastructure.yaml'
  pull_request:
    paths:
      - 'infrastructure.yaml'

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-and-plan:
    runs-on: ubuntu-latest
    outputs:
      validation_result: ${{ steps.validate.outputs.result }}
      environment: ${{ steps.validate.outputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Validate infrastructure YAML
        id: validate
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          python << 'EOF'
          import yaml
          import json
          import sys
          import os
          import subprocess
          import re

          infra_file = "infrastructure.yaml"

          if not os.path.exists(infra_file):
              print(f"::error::Infrastructure file not found: {infra_file}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
              sys.exit(1)

          try:
              with open(infra_file, 'r') as f:
                  # Support multi-document YAML
                  documents = list(yaml.safe_load_all(f))
                  documents = [d for d in documents if d is not None]
          except yaml.YAMLError as e:
              print(f"::error::Invalid YAML syntax: {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
              sys.exit(1)

          if not documents:
              print("::error::No valid documents found in YAML")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
              sys.exit(1)

          valid_patterns = [
              'keyvault', 'postgresql', 'mongodb', 'storage', 'function-app',
              'sql-database', 'eventhub', 'aks-namespace', 'linux-vm', 'static-site',
              'web-app', 'api-backend', 'microservice', 'data-pipeline'
          ]

          # Cache for version validation
          validated_versions = {}

          def validate_version_exists(pattern, version):
              """Check if a pattern version exists as a GitHub release."""
              cache_key = f"{pattern}@{version}"
              if cache_key in validated_versions:
                  return validated_versions[cache_key]

              # Check if release exists via gh CLI
              tag = f"{pattern}/v{version}"
              try:
                  result = subprocess.run(
                      ['gh', 'release', 'view', tag,
                       '--repo', 'csGIT34/infrastructure-automation',
                       '--json', 'tagName'],
                      capture_output=True,
                      text=True,
                      timeout=30
                  )
                  exists = result.returncode == 0
              except Exception as e:
                  print(f"::warning::Could not validate version {version} for {pattern}: {e}")
                  # Allow if we can't validate (graceful degradation)
                  exists = True

              validated_versions[cache_key] = exists
              return exists

          def validate_document(doc, index):
              """Validate a single document and return errors."""
              errors = []
              warnings = []
              action = doc.get('action', 'create')

              # Validate action field
              if action not in ['create', 'destroy']:
                  errors.append(f"Doc {index}: Invalid action '{action}'. Must be 'create' or 'destroy'")

              # Only pattern-based requests are supported
              if 'pattern' not in doc:
                  errors.append(f"Doc {index}: Missing 'pattern' field. Only pattern-based requests are supported.")

              # Validate metadata
              if 'metadata' not in doc:
                  errors.append(f"Doc {index}: Missing 'metadata' section")
              else:
                  metadata = doc['metadata']
                  required_meta = ['project', 'environment', 'business_unit', 'owners']
                  for field in required_meta:
                      if field not in metadata:
                          errors.append(f"Doc {index}: Missing metadata.{field}")

                  # owners must be a list
                  if 'owners' in metadata and not isinstance(metadata['owners'], list):
                      errors.append(f"Doc {index}: metadata.owners must be a list of email addresses")

                  # Validate environment
                  env = metadata.get('environment', '')
                  if env not in ['dev', 'staging', 'prod']:
                      errors.append(f"Doc {index}: Invalid environment: {env}. Must be dev, staging, or prod")

              # Validate pattern
              if 'pattern' in doc:
                  pattern = doc.get('pattern', '')
                  if pattern not in valid_patterns:
                      errors.append(f"Doc {index}: Invalid pattern: {pattern}. Valid patterns: {', '.join(valid_patterns)}")

                  # Validate pattern_version (required)
                  version = doc.get('pattern_version', '')
                  if not version:
                      errors.append(f"Doc {index}: Missing 'pattern_version' field. You must pin to a specific version.")
                  else:
                      # Validate version format
                      if not re.match(r'^\d+\.\d+\.\d+(-[a-z0-9]+)?$', version):
                          errors.append(f"Doc {index}: Invalid pattern_version format: {version}. Expected: X.Y.Z (e.g., 1.2.0)")
                      # Validate version exists (only for create actions)
                      elif action == 'create' and pattern in valid_patterns:
                          if not validate_version_exists(pattern, version):
                              errors.append(f"Doc {index}: Version {version} not found for pattern {pattern}. Check available releases.")

                  # Validate config section
                  if 'config' not in doc:
                      errors.append(f"Doc {index}: Missing 'config' section for pattern request")
                  else:
                      cfg = doc['config']
                      if 'name' not in cfg:
                          errors.append(f"Doc {index}: Missing config.name")
                      if 'size' in cfg and cfg['size'] not in ['small', 'medium', 'large']:
                          errors.append(f"Doc {index}: Invalid size: {cfg['size']}. Must be small, medium, or large")

              return errors, warnings, action

          # Validate all documents
          all_errors = []
          all_warnings = []
          create_count = 0
          destroy_count = 0
          environments = set()
          versions_used = {}

          for i, doc in enumerate(documents):
              errors, warnings, action = validate_document(doc, i)
              all_errors.extend(errors)
              all_warnings.extend(warnings)
              if not errors:
                  if action == 'create':
                      create_count += 1
                  else:
                      destroy_count += 1
                  environments.add(doc.get('metadata', {}).get('environment', 'dev'))

                  # Track versions used
                  pattern = doc.get('pattern', '')
                  version = doc.get('pattern_version', '')
                  if pattern and version:
                      versions_used[pattern] = version

          if all_warnings:
              for warn in all_warnings:
                  print(f"::warning::{warn}")

          if all_errors:
              print("::error::Validation failed")
              for err in all_errors:
                  print(f"  - {err}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
                  f.write(f"errors={json.dumps(all_errors)}\n")
              sys.exit(1)

          # Get primary environment (first document's environment)
          environment = documents[0].get('metadata', {}).get('environment', 'dev')

          print(f"Validation passed!")
          print(f"  Documents: {len(documents)}")
          print(f"  Create: {create_count}, Destroy: {destroy_count}")
          print(f"  Versions: {versions_used}")
          if destroy_count > 0:
              print(f"  Warning: {destroy_count} pattern(s) will be DESTROYED")

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("result=passed\n")
              f.write(f"environment={environment}\n")
              f.write(f"document_count={len(documents)}\n")
              f.write(f"create_count={create_count}\n")
              f.write(f"destroy_count={destroy_count}\n")
              f.write(f"versions={json.dumps(versions_used)}\n")
          EOF

      - name: Generate Plan Preview
        id: plan
        run: |
          python << 'PLANEOF'
          import yaml
          import json
          import os

          with open("infrastructure.yaml", 'r') as f:
              # Support multi-document YAML
              documents = list(yaml.safe_load_all(f))
              documents = [d for d in documents if d is not None]

          pattern_components = {
              'keyvault': ['Key Vault', 'Security Groups', 'RBAC Assignments'],
              'postgresql': ['PostgreSQL Server', 'Database', 'Key Vault', 'Security Groups'],
              'mongodb': ['Cosmos DB (MongoDB)', 'Key Vault', 'Security Groups'],
              'storage': ['Storage Account', 'Blob Containers', 'Security Groups'],
              'function-app': ['Function App', 'App Service Plan', 'Storage Account', 'Key Vault', 'Security Groups'],
              'sql-database': ['SQL Server', 'Database', 'Key Vault', 'Security Groups'],
              'eventhub': ['Event Hub Namespace', 'Event Hub', 'Key Vault', 'Security Groups'],
              'aks-namespace': ['Kubernetes Namespace', 'Resource Quotas', 'Security Groups'],
              'linux-vm': ['Virtual Machine', 'Network Interface', 'Key Vault', 'Security Groups'],
              'static-site': ['Static Web App', 'Security Groups'],
              'web-app': ['Static Web App', 'Function App', 'Database', 'Key Vault', 'Security Groups'],
              'api-backend': ['Function App', 'Database', 'Key Vault', 'Security Groups'],
              'microservice': ['AKS Namespace', 'Event Hub', 'Storage', 'Key Vault', 'Security Groups'],
              'data-pipeline': ['Event Hub', 'Function App', 'Data Lake Storage', 'MongoDB', 'Key Vault', 'Security Groups']
          }

          # Separate documents by action
          destroy_docs = [(i, d) for i, d in enumerate(documents) if d.get('action') == 'destroy']
          create_docs = [(i, d) for i, d in enumerate(documents) if d.get('action', 'create') == 'create']

          # Generate markdown preview
          preview = "## Infrastructure Plan Preview\n\n"

          # Show summary for multi-document
          if len(documents) > 1:
              preview += f"### Summary\n"
              preview += f"- **Total Documents:** {len(documents)}\n"
              preview += f"- **Create:** {len(create_docs)} pattern(s)\n"
              preview += f"- **Destroy:** {len(destroy_docs)} pattern(s)\n\n"

              if destroy_docs:
                  preview += "> **WARNING:** This request includes DESTROY actions. "
                  preview += "Resources will be permanently deleted.\n\n"

              preview += "### Execution Order\n"
              preview += "| Order | Doc | Action | Pattern | Version | Name |\n"
              preview += "|-------|-----|--------|---------|---------|------|\n"
              order = 1
              # Destroy first
              for i, doc in destroy_docs:
                  name = doc.get('config', {}).get('name', 'N/A')
                  version = doc.get('pattern_version', 'N/A')
                  preview += f"| {order} | {i} | DESTROY | `{doc.get('pattern', 'N/A')}` | `{version}` | `{name}` |\n"
                  order += 1
              # Then create
              for i, doc in create_docs:
                  name = doc.get('config', {}).get('name', 'N/A')
                  version = doc.get('pattern_version', 'N/A')
                  preview += f"| {order} | {i} | CREATE | `{doc.get('pattern', 'N/A')}` | `{version}` | `{name}` |\n"
                  order += 1
              preview += "\n---\n\n"

          # Process destroy docs first in preview
          for section_name, section_docs, icon in [
              ("Destroy Actions", destroy_docs, ""),
              ("Create Actions", create_docs, "") if len(documents) > 1 else ("Pattern Request", create_docs, "")
          ]:
              if not section_docs:
                  continue

              if len(documents) > 1:
                  preview += f"## {section_name}\n\n"

              for doc_idx, doc in section_docs:
                  metadata = doc.get('metadata', {})
                  project = metadata.get('project', 'unknown')
                  env = metadata.get('environment', 'dev')
                  pattern = doc.get('pattern', '')
                  version = doc.get('pattern_version', 'N/A')
                  cfg = doc.get('config', {})
                  size = cfg.get('size', 'small')
                  action = doc.get('action', 'create')

                  if len(documents) > 1:
                      preview += f"### Document {doc_idx}: {pattern}\n\n"

                  if action == 'destroy':
                      preview += "> **This pattern will be DESTROYED**\n\n"

                  preview += "| Property | Value |\n"
                  preview += "|----------|-------|\n"
                  if len(documents) > 1:
                      preview += f"| Action | `{action.upper()}` |\n"
                  preview += f"| Pattern | `{pattern}` |\n"
                  preview += f"| Version | `{version}` |\n"
                  preview += f"| Project | `{project}` |\n"
                  preview += f"| Environment | `{env}` |\n"
                  preview += f"| Size | `{size}` |\n"
                  preview += f"| Business Unit | `{metadata.get('business_unit', 'N/A')}` |\n"
                  preview += f"| Owners | `{', '.join(metadata.get('owners', []))}` |\n"
                  preview += f"| Location | `{metadata.get('location', 'eastus')}` |\n\n"

                  # Pattern-specific config
                  preview += "#### Configuration\n"
                  preview += "| Setting | Value |\n"
                  preview += "|---------|-------|\n"
                  for key, value in cfg.items():
                      preview += f"| {key} | `{value}` |\n"
                  preview += "\n"

                  # What will be created/destroyed
                  action_verb = "Destroyed" if action == 'destroy' else "Created"
                  preview += f"#### What Will Be {action_verb}\n"
                  components = pattern_components.get(pattern, ['Unknown components'])
                  for component in components:
                      prefix = "X" if action == 'destroy' else "-"
                      preview += f"{prefix} {component}\n"
                  preview += "\n"

                  # Environment features (only for create)
                  if action == 'create':
                      preview += "#### Environment Features\n"
                      if env == 'prod':
                          preview += "- Diagnostic logging enabled\n"
                          preview += "- Access reviews enabled\n"
                          preview += "- Geo-redundant backup (if applicable)\n"
                          preview += "- Purge protection enabled\n"
                      elif env == 'staging':
                          preview += "- Diagnostic logging enabled\n"
                          preview += "- Standard backup retention\n"
                      else:
                          preview += "- Development configuration\n"
                          preview += "- Minimal backup retention\n"
                      preview += "\n"

                  preview += f"#### Resource Group\n"
                  preview += f"`rg-{project}-{env}`\n\n"

                  if len(documents) > 1:
                      preview += "---\n\n"

          preview += "---\n"
          preview += "**On merge to main**, these changes will be automatically provisioned.\n"

          with open('plan_preview.md', 'w') as f:
              f.write(preview)

          print(preview)
          PLANEOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let body = '## Infrastructure Plan\n\n';

            try {
              if (fs.existsSync('plan_preview.md')) {
                body = fs.readFileSync('plan_preview.md', 'utf8');
              } else {
                body += 'Infrastructure configuration validated successfully.\n\n';
                body += 'Merge this PR to provision the infrastructure.';
              }
            } catch (e) {
              body += 'Validation passed. See workflow summary for details.';
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Infrastructure Plan')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Create Job Summary
        if: always()
        run: |
          if [ -f plan_preview.md ]; then
            cat plan_preview.md >> $GITHUB_STEP_SUMMARY
          fi

  # Trigger provisioning on merge to main
  provision:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: validate-and-plan

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_APP_ID }}
          private-key: ${{ secrets.INFRA_APP_PRIVATE_KEY }}
          owner: csGIT34
          repositories: infrastructure-automation

      - name: Trigger Provisioning
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Base64 encode the YAML content to safely pass in JSON payload
          YAML_CONTENT=$(base64 -w0 infrastructure.yaml)

          curl -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/csGIT34/infrastructure-automation/dispatches \
            -d "{
              \"event_type\": \"provision\",
              \"client_payload\": {
                \"repository\": \"${{ github.repository }}\",
                \"commit_sha\": \"${{ github.sha }}\",
                \"yaml_content\": \"$YAML_CONTENT\"
              }
            }"

          echo "Triggered infrastructure provisioning"
          echo ""
          echo "Request details:"
          echo "  Repository: ${{ github.repository }}"
          echo "  Commit: ${{ github.sha }}"

          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Infrastructure Provisioning Triggered

          | Property | Value |
          |----------|-------|
          | Repository | \`${{ github.repository }}\` |
          | Commit | \`${{ github.sha }}\` |
          | Triggered By | \`${{ github.actor }}\` |

          Provisioning is running in the [infrastructure-automation](https://github.com/csGIT34/infrastructure-automation/actions) repository.
          EOF
