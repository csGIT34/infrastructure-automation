# Infrastructure GitOps Workflow Template
# Copy this file to your repository: .github/workflows/infrastructure.yaml
#
# Required secrets:
#   INFRA_SERVICE_BUS_SAS_KEY - Service Bus SAS key for submitting requests
#     Get it from your platform team or run:
#       az servicebus namespace authorization-rule keys list \
#         --namespace-name sb-infra-api-rrkkz6a8 \
#         --resource-group rg-infrastructure-api \
#         --name RootManageSharedAccessKey \
#         --query primaryKey -o tsv
#
#   INFRA_APP_ID - GitHub App ID for Infrastructure Dispatch app
#   INFRA_APP_PRIVATE_KEY - GitHub App private key (PEM format)
#     Get these from your platform team or create the app at:
#     https://github.com/settings/apps
#
# Usage:
# 1. Create infrastructure.yaml in your repo root (see templates/infrastructure.yaml)
# 2. Create a PR to see the plan preview with additions/deletions
# 3. Merge to main to provision resources (triggers immediate processing)
#
# Features:
# - Validates YAML syntax and required fields
# - Shows plan preview comparing against last successful deployment
# - Indicates which resources will be added, removed, or unchanged
# - Posts plan as PR comment
# - Submits to provisioning queue on merge

name: Infrastructure GitOps

on:
  push:
    branches:
      - main
    paths:
      - 'infrastructure.yaml'
  pull_request:
    paths:
      - 'infrastructure.yaml'

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-and-plan:
    runs-on: ubuntu-latest
    outputs:
      validation_result: ${{ steps.validate.outputs.result }}
      plan_markdown: ${{ steps.plan.outputs.markdown }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml requests

      - name: Validate infrastructure YAML
        id: validate
        run: |
          python << 'EOF'
          import yaml
          import json
          import sys
          import os

          infra_file = "infrastructure.yaml"

          if not os.path.exists(infra_file):
              print(f"::error::Infrastructure file not found: {infra_file}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
              sys.exit(1)

          try:
              with open(infra_file, 'r') as f:
                  config = yaml.safe_load(f)
          except yaml.YAMLError as e:
              print(f"::error::Invalid YAML syntax: {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
              sys.exit(1)

          # Validate required fields
          errors = []

          if 'metadata' not in config:
              errors.append("Missing 'metadata' section")
          else:
              metadata = config['metadata']
              required_meta = ['project_name', 'environment', 'business_unit', 'cost_center', 'owner_email']
              for field in required_meta:
                  if field not in metadata:
                      errors.append(f"Missing metadata.{field}")

          if 'resources' not in config:
              errors.append("Missing 'resources' section")
          elif not isinstance(config.get('resources'), list):
              errors.append("'resources' must be a list")
          elif len(config.get('resources', [])) == 0:
              errors.append("'resources' list is empty")
          else:
              valid_types = ['storage_account', 'keyvault', 'postgresql', 'mongodb', 'azure_sql', 'eventhub', 'function_app', 'linux_vm', 'aks_namespace', 'static_web_app']
              for i, resource in enumerate(config['resources']):
                  if 'type' not in resource:
                      errors.append(f"Resource {i+1}: missing 'type'")
                  elif resource['type'] not in valid_types:
                      errors.append(f"Resource {i+1}: invalid type '{resource['type']}'. Valid: {', '.join(valid_types)}")
                  if 'name' not in resource:
                      errors.append(f"Resource {i+1}: missing 'name'")

          if errors:
              print("::error::Validation failed")
              for err in errors:
                  print(f"  - {err}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
                  f.write(f"errors={json.dumps(errors)}\n")
              sys.exit(1)

          print("Validation passed!")
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("result=passed\n")
          EOF

      - name: Generate Plan Preview
        id: plan
        env:
          PLAN_API_URL: https://func-infra-api-rrkkz6a8.azurewebsites.net/api/plan
        run: |
          python << 'PLANEOF'
          import yaml
          import json
          import os
          import requests

          PLAN_API_URL = os.environ['PLAN_API_URL']

          # Load current config
          with open("infrastructure.yaml", 'r') as f:
              yaml_content = f.read()
              config = yaml.safe_load(yaml_content)

          metadata = config['metadata']
          project = metadata.get('project_name', 'unknown')
          env = metadata.get('environment', 'dev')

          # Call the plan API to compare against last successful deployment
          try:
              response = requests.post(PLAN_API_URL, json={
                  'project_name': project,
                  'environment': env,
                  'proposed_yaml': yaml_content
              }, timeout=30)
              response.raise_for_status()
              plan_data = response.json()
          except Exception as e:
              print(f"Warning: Could not reach plan API: {e}")
              print("Falling back to showing all resources as new")
              plan_data = {
                  'changes': {
                      'added': [{'type': r['type'], 'name': r['name'], 'azure_name': 'unknown'} for r in config.get('resources', [])],
                      'removed': [],
                      'unchanged': []
                  },
                  'summary': {'added': len(config.get('resources', [])), 'removed': 0, 'unchanged': 0},
                  'warnings': ['Could not connect to plan API. Showing all resources as additions.'],
                  'last_deployment': None
              }

          changes = plan_data.get('changes', {})
          summary = plan_data.get('summary', {})
          warnings = plan_data.get('warnings', [])
          last_deployment = plan_data.get('last_deployment')

          # Generate markdown preview
          preview = "## Infrastructure Plan Preview\n\n"
          preview += "### Project Information\n"
          preview += "| Property | Value |\n"
          preview += "|----------|-------|\n"
          preview += f"| Project Name | `{metadata.get('project_name')}` |\n"
          preview += f"| Environment | `{metadata.get('environment')}` |\n"
          preview += f"| Business Unit | `{metadata.get('business_unit')}` |\n"
          preview += f"| Cost Center | `{metadata.get('cost_center')}` |\n"
          preview += f"| Owner | `{metadata.get('owner_email')}` |\n"
          preview += f"| Location | `{metadata.get('location', 'centralus')}` |\n\n"
          preview += "### Last Successful Deployment\n"
          if last_deployment:
              preview += "| Property | Value |\n|----------|-------|\n"
              preview += f"| Request ID | `{last_deployment.get('request_id', 'N/A')}` |\n"
              preview += f"| Deployed At | `{last_deployment.get('deployed_at', 'N/A')}` |\n"
          else:
              preview += "_No previous deployment found for this project/environment._\n"
          preview += "\n### Changes Summary (vs. Last Deployment)\n"
          preview += "| Added | Removed | Unchanged |\n"
          preview += "|-------|---------|----------|\n"
          preview += f"| {summary.get('added', 0)} | {summary.get('removed', 0)} | {summary.get('unchanged', 0)} |\n\n"
          preview += "### Resource Changes\n\n"
          preview += "| Status | Type | Name | Azure Resource |\n"
          preview += "|--------|------|------|----------------|\n"

          # Show added resources
          for r in changes.get('added', []):
              preview += f"| + **Add** | `{r['type']}` | `{r['name']}` | `{r.get('azure_name', '')}` |\n"

          # Show removed resources
          for r in changes.get('removed', []):
              preview += f"| - **Remove** | `{r['type']}` | `{r['name']}` | `{r.get('azure_name', '')}` |\n"

          # Show unchanged resources
          for r in changes.get('unchanged', []):
              preview += f"| = No change | `{r['type']}` | `{r['name']}` | `{r.get('azure_name', '')}` |\n"

          preview += f"\n### Resource Group\n"
          preview += f"`rg-{project}-{env}`\n\n"
          preview += "---\n"

          # Show warnings
          if warnings:
              for warning in warnings:
                  preview += f"**Note:** {warning}\n\n"

          if summary.get('added', 0) > 0 or summary.get('removed', 0) > 0:
              preview += "**This PR will modify infrastructure.** Review changes carefully before merging.\n\n"
          else:
              preview += "**No infrastructure changes detected.**\n\n"

          preview += "**On merge to main**, these changes will be automatically applied.\n\n"
          preview += "Track provisioning status at: https://wonderful-field-088efae10.1.azurestaticapps.net\n"

          with open('plan_preview.md', 'w') as f:
              f.write(preview)

          print(preview)
          PLANEOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let body = '## Infrastructure Plan\n\n';

            try {
              if (fs.existsSync('plan_preview.md')) {
                body = fs.readFileSync('plan_preview.md', 'utf8');
              } else {
                body += 'Infrastructure configuration validated successfully.\n\n';
                body += 'Merge this PR to provision the infrastructure.';
              }
            } catch (e) {
              body += 'Validation passed. See workflow summary for details.';
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Infrastructure Plan')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Create Job Summary
        if: always()
        run: |
          if [ -f plan_preview.md ]; then
            cat plan_preview.md >> $GITHUB_STEP_SUMMARY
          fi

  # Submit to queue on merge to main
  provision:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: validate-and-plan

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Submit to Infrastructure Queue
        env:
          SAS_KEY: ${{ secrets.INFRA_SERVICE_BUS_SAS_KEY }}
        run: |
          python << 'EOF'
          import yaml
          import json
          import hashlib
          import hmac
          import base64
          import time
          import urllib.parse
          import urllib.request
          import os

          with open("infrastructure.yaml", 'r') as f:
              yaml_content = f.read()
              config = yaml.safe_load(yaml_content)

          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
          sha = os.environ.get('GITHUB_SHA', 'unknown')[:8]
          timestamp = int(time.time())
          request_id = f"gitops-{repo.replace('/', '-')}-{sha}-{timestamp}"

          namespace = "sb-infra-api-rrkkz6a8"
          queue_name = f"infrastructure-requests-{config['metadata']['environment']}"
          sas_key = os.environ['SAS_KEY']
          sas_key_name = "RootManageSharedAccessKey"

          uri = f"https://{namespace}.servicebus.windows.net/{queue_name}".lower()
          expiry = int(time.time()) + 3600
          string_to_sign = f"{urllib.parse.quote_plus(uri)}\n{expiry}"
          signature = base64.b64encode(
              hmac.new(sas_key.encode('utf-8'), string_to_sign.encode('utf-8'), hashlib.sha256).digest()
          ).decode('utf-8')
          sas_token = f"SharedAccessSignature sr={urllib.parse.quote_plus(uri)}&sig={urllib.parse.quote_plus(signature)}&se={expiry}&skn={sas_key_name}"

          message = {
              'request_id': request_id,
              'yaml_content': yaml_content,
              'requester_email': config['metadata'].get('owner_email', 'gitops@automation'),
              'metadata': {
                  'source': 'gitops',
                  'repository': repo,
                  'commit_sha': os.environ.get('GITHUB_SHA'),
                  'triggered_by': os.environ.get('GITHUB_ACTOR'),
                  'environment': config['metadata']['environment'],
                  'submitted_at': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
              }
          }

          url = f"https://{namespace}.servicebus.windows.net/{queue_name}/messages"
          data = json.dumps(message).encode('utf-8')

          req = urllib.request.Request(url, data=data, method='POST')
          req.add_header('Authorization', sas_token)
          req.add_header('Content-Type', 'application/json')

          try:
              response = urllib.request.urlopen(req)
              print(f"Successfully submitted infrastructure request!")
              print(f"   Request ID: {request_id}")
              print(f"   Queue: {queue_name}")
              print(f"   Repository: {repo}")
              print(f"\nTrack status at: https://wonderful-field-088efae10.1.azurestaticapps.net")

              with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as f:
                  f.write("## Infrastructure Request Submitted\n\n")
                  f.write(f"| Property | Value |\n")
                  f.write(f"|----------|-------|\n")
                  f.write(f"| Request ID | `{request_id}` |\n")
                  f.write(f"| Queue | `{queue_name}` |\n")
                  f.write(f"| Repository | `{repo}` |\n")
                  f.write(f"\n[Track Status](https://wonderful-field-088efae10.1.azurestaticapps.net)\n")

          except urllib.error.HTTPError as e:
              print(f"::error::Failed to submit: {e.code} {e.reason}")
              print(e.read().decode())
              exit(1)
          EOF

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_APP_ID }}
          private-key: ${{ secrets.INFRA_APP_PRIVATE_KEY }}
          owner: csGIT34
          repositories: infrastructure-automation

      - name: Trigger Queue Consumer
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          curl -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/csGIT34/infrastructure-automation/dispatches \
            -d '{"event_type":"infrastructure-request","client_payload":{"source":"${{ github.repository }}","sha":"${{ github.sha }}"}}'
          echo "Triggered infrastructure queue consumer"
