name: GitOps Infrastructure Provisioning

on:
  workflow_call:
    inputs:
      infrastructure_file:
        description: 'Path to infrastructure YAML file'
        required: false
        type: string
        default: 'infrastructure.yaml'
      environment:
        description: 'Target environment (dev, staging, prod)'
        required: false
        type: string
        default: 'dev'
      action:
        description: 'Action to perform (validate, plan, apply)'
        required: true
        type: string
    secrets:
      INFRA_SERVICE_BUS_SAS_KEY:
        required: true
    outputs:
      request_id:
        description: 'The infrastructure request ID'
        value: ${{ jobs.process.outputs.request_id }}
      validation_result:
        description: 'Validation result'
        value: ${{ jobs.process.outputs.validation_result }}

jobs:
  process:
    runs-on: [self-hosted, linux, local]
    outputs:
      request_id: ${{ steps.submit.outputs.request_id }}
      validation_result: ${{ steps.validate.outputs.result }}

    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: pip3 install pyyaml

      - name: Validate infrastructure YAML
        id: validate
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import sys
          import os

          infra_file = "${{ inputs.infrastructure_file }}"

          if not os.path.exists(infra_file):
              print(f"::error::Infrastructure file not found: {infra_file}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
                  f.write("error=Infrastructure file not found\n")
              sys.exit(1)

          try:
              with open(infra_file, 'r') as f:
                  config = yaml.safe_load(f)
          except yaml.YAMLError as e:
              print(f"::error::Invalid YAML syntax: {e}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
                  f.write(f"error=Invalid YAML: {e}\n")
              sys.exit(1)

          # Validate required fields
          errors = []

          if 'metadata' not in config:
              errors.append("Missing 'metadata' section")
          else:
              metadata = config['metadata']
              required_meta = ['project_name', 'environment', 'business_unit', 'cost_center', 'owner_email']
              for field in required_meta:
                  if field not in metadata:
                      errors.append(f"Missing metadata.{field}")

          if 'resources' not in config:
              errors.append("Missing 'resources' section")
          elif not isinstance(config.get('resources'), list):
              errors.append("'resources' must be a list")
          elif len(config.get('resources', [])) == 0:
              errors.append("'resources' list is empty")
          else:
              valid_types = ['storage_account', 'keyvault', 'postgresql', 'mongodb', 'eventhub', 'function_app', 'linux_vm', 'aks_namespace', 'static_web_app', 'azure_sql']
              for i, resource in enumerate(config['resources']):
                  if 'type' not in resource:
                      errors.append(f"Resource {i+1}: missing 'type'")
                  elif resource['type'] not in valid_types:
                      errors.append(f"Resource {i+1}: invalid type '{resource['type']}'. Valid: {valid_types}")
                  if 'name' not in resource:
                      errors.append(f"Resource {i+1}: missing 'name'")

          if errors:
              print("::error::Validation failed:")
              for err in errors:
                  print(f"  - {err}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("result=failed\n")
                  f.write(f"errors={json.dumps(errors)}\n")
              sys.exit(1)

          # Generate summary
          metadata = config['metadata']
          resources = config['resources']

          summary = {
              'project_name': metadata.get('project_name'),
              'environment': metadata.get('environment'),
              'business_unit': metadata.get('business_unit'),
              'location': metadata.get('location', 'centralus'),
              'resource_count': len(resources),
              'resources': [{'type': r['type'], 'name': r['name']} for r in resources]
          }

          print("Validation passed!")
          print(f"Project: {summary['project_name']}")
          print(f"Environment: {summary['environment']}")
          print(f"Resources: {summary['resource_count']}")

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("result=passed\n")
              f.write(f"summary={json.dumps(summary)}\n")

          # Save for later steps
          with open('validation_summary.json', 'w') as f:
              json.dump(summary, f)

          EOF

      - name: Generate Plan Preview
        id: plan
        if: inputs.action == 'plan' || inputs.action == 'apply'
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import os

          with open("${{ inputs.infrastructure_file }}", 'r') as f:
              config = yaml.safe_load(f)

          metadata = config['metadata']
          resources = config['resources']

          # Generate markdown preview
          preview = f"""## Infrastructure Plan Preview

          ### Project Information
          | Property | Value |
          |----------|-------|
          | Project Name | `{metadata.get('project_name')}` |
          | Environment | `{metadata.get('environment')}` |
          | Business Unit | `{metadata.get('business_unit')}` |
          | Cost Center | `{metadata.get('cost_center')}` |
          | Owner | `{metadata.get('owner_email')}` |
          | Location | `{metadata.get('location', 'centralus')}` |

          ### Resources to be Provisioned

          | # | Type | Name | Expected Resource Name |
          |---|------|------|----------------------|
          """

          project = metadata.get('project_name', 'unknown')
          env = metadata.get('environment', 'dev')

          for i, r in enumerate(resources, 1):
              rtype = r['type']
              rname = r['name']

              # Generate expected Azure resource name
              if rtype == 'storage_account':
                  azure_name = f"{project}{rname}{env}".replace('-', '').replace('_', '')[:24]
              elif rtype == 'keyvault':
                  azure_name = f"kv-{project}-{rname}-{env}"[:24]
              elif rtype == 'postgresql':
                  azure_name = f"psql-{project}-{rname}-{env}"
              else:
                  azure_name = f"{rtype}-{project}-{rname}-{env}"

              preview += f"| {i} | `{rtype}` | `{rname}` | `{azure_name}` |\n"

          preview += f"""
          ### Resource Group
          `rg-{project}-{env}`

          ---
          *This is a preview. Merge to main to provision these resources.*
          """

          # Write to file for PR comment
          with open('plan_preview.md', 'w') as f:
              f.write(preview)

          # Set output
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("has_plan=true\n")

          print(preview)
          EOF

      - name: Submit to Infrastructure Queue
        id: submit
        if: inputs.action == 'apply'
        env:
          SAS_KEY: ${{ secrets.INFRA_SERVICE_BUS_SAS_KEY }}
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import hashlib
          import hmac
          import base64
          import time
          import urllib.parse
          import urllib.request
          import os

          # Load config
          with open("${{ inputs.infrastructure_file }}", 'r') as f:
              yaml_content = f.read()
              config = yaml.safe_load(yaml_content)

          # Override environment if specified
          target_env = "${{ inputs.environment }}"
          if target_env:
              config['metadata']['environment'] = target_env
              yaml_content = yaml.dump(config)

          # Generate request ID
          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
          sha = os.environ.get('GITHUB_SHA', 'unknown')[:8]
          timestamp = int(time.time())
          request_id = f"gitops-{repo.replace('/', '-')}-{sha}-{timestamp}"

          # Service Bus details
          namespace = "sb-infra-api-rrkkz6a8"
          queue_name = f"infrastructure-requests-{config['metadata']['environment']}"
          sas_key = os.environ['SAS_KEY']
          sas_key_name = "RootManageSharedAccessKey"

          # Generate SAS token
          uri = f"https://{namespace}.servicebus.windows.net/{queue_name}".lower()
          expiry = int(time.time()) + 3600
          string_to_sign = f"{urllib.parse.quote_plus(uri)}\n{expiry}"
          signature = base64.b64encode(
              hmac.new(sas_key.encode('utf-8'), string_to_sign.encode('utf-8'), hashlib.sha256).digest()
          ).decode('utf-8')
          sas_token = f"SharedAccessSignature sr={urllib.parse.quote_plus(uri)}&sig={urllib.parse.quote_plus(signature)}&se={expiry}&skn={sas_key_name}"

          # Prepare message
          message = {
              'request_id': request_id,
              'yaml_content': yaml_content,
              'requester_email': config['metadata'].get('owner_email', 'gitops@automation'),
              'metadata': {
                  'source': 'gitops',
                  'repository': repo,
                  'commit_sha': os.environ.get('GITHUB_SHA'),
                  'triggered_by': os.environ.get('GITHUB_ACTOR'),
                  'environment': config['metadata']['environment'],
                  'submitted_at': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
              }
          }

          # Send to Service Bus
          url = f"https://{namespace}.servicebus.windows.net/{queue_name}/messages"
          data = json.dumps(message).encode('utf-8')

          req = urllib.request.Request(url, data=data, method='POST')
          req.add_header('Authorization', sas_token)
          req.add_header('Content-Type', 'application/json')

          try:
              response = urllib.request.urlopen(req)
              print(f"Successfully submitted request: {request_id}")
              print(f"Queue: {queue_name}")
              print(f"Repository: {repo}")

              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"request_id={request_id}\n")
                  f.write(f"queue={queue_name}\n")
                  f.write("submitted=true\n")

          except urllib.error.HTTPError as e:
              print(f"::error::Failed to submit: {e.code} {e.reason}")
              print(e.read().decode())
              exit(1)
          EOF

      - name: Create Job Summary
        if: always()
        run: |
          if [ -f plan_preview.md ]; then
            cat plan_preview.md >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ steps.submit.outputs.submitted }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "## Submission Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Request ID | \`${{ steps.submit.outputs.request_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Queue | \`${{ steps.submit.outputs.queue }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Submitted for provisioning |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Track status at: https://wonderful-field-088efae10.1.azurestaticapps.net" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload plan artifact
        if: inputs.action == 'plan' && steps.plan.outputs.has_plan == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-plan
          path: plan_preview.md
