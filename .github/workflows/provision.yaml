name: Infrastructure Provision

on:
  repository_dispatch:
    types: [provision]
  workflow_dispatch:
    inputs:
      repository:
        description: 'Source repository (owner/repo)'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA'
        required: true
        type: string
      yaml_url:
        description: 'Raw URL to infrastructure.yaml'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  TF_STATE_STORAGE_ACCOUNT: ${{ secrets.TF_STATE_STORAGE_ACCOUNT }}
  TF_STATE_CONTAINER: "tfstate"

jobs:
  provision:
    runs-on: ["self-hosted", "linux"]

    steps:
      - name: Checkout infrastructure-automation
        uses: actions/checkout@v4

      - name: Extract request info
        id: request
        run: |
          # Handle both repository_dispatch and workflow_dispatch
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            REPO="${{ github.event.client_payload.repository }}"
            SHA="${{ github.event.client_payload.commit_sha }}"
            YAML_URL="${{ github.event.client_payload.yaml_url }}"
          else
            REPO="${{ inputs.repository }}"
            SHA="${{ inputs.commit_sha }}"
            YAML_URL="${{ inputs.yaml_url }}"
          fi

          # Extract owner and repo name for GitHub App token
          REPO_OWNER="${REPO%%/*}"
          REPO_NAME="${REPO##*/}"

          echo "repository=$REPO" >> $GITHUB_OUTPUT
          echo "repo_owner=$REPO_OWNER" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "commit_sha=$SHA" >> $GITHUB_OUTPUT
          echo "yaml_url=$YAML_URL" >> $GITHUB_OUTPUT
          echo "request_id=provision-${REPO//\//-}-${SHA:0:8}-$(date +%s)" >> $GITHUB_OUTPUT

      # Generate token for communicating back to the source repo
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_APP_ID }}
          private-key: ${{ secrets.INFRA_APP_PRIVATE_KEY }}
          owner: ${{ steps.request.outputs.repo_owner }}
          repositories: ${{ steps.request.outputs.repo_name }}

      # Set commit status to pending immediately
      - name: Set Commit Status - Pending
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          gh api repos/${{ steps.request.outputs.repository }}/statuses/${{ steps.request.outputs.commit_sha }} \
            -f state=pending \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="Infrastructure provisioning in progress..." \
            -f context="infrastructure/provision"

      - name: Write infrastructure.yaml
        run: |
          # Get YAML content from payload (base64 encoded for safety)
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "${{ github.event.client_payload.yaml_content }}" | base64 -d > infrastructure.yaml
          else
            # For manual workflow_dispatch, download from URL (requires public repo or auth)
            curl -sL "${{ steps.request.outputs.yaml_url }}" -o infrastructure.yaml
          fi
          echo "Infrastructure request from ${{ steps.request.outputs.repository }}:"
          cat infrastructure.yaml

      - name: Install Python dependencies
        run: |
          pip3 install --quiet --break-system-packages pyyaml

      - name: Resolve pattern and validate
        id: resolve
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import json
          import os
          import subprocess
          import sys

          with open('infrastructure.yaml', 'r') as f:
              config = yaml.safe_load(f)

          # Check if this is a pattern-based request
          if 'pattern' not in config:
              print("::error::Only pattern-based requests are supported")
              sys.exit(1)

          metadata = config.get('metadata', {})
          pattern = config['pattern']
          environment = metadata.get('environment', 'dev')
          project = metadata.get('project', 'unknown')
          business_unit = metadata.get('business_unit', 'default')

          print(f"Pattern: {pattern}")
          print(f"Project: {project}")
          print(f"Environment: {environment}")
          print(f"Business Unit: {business_unit}")

          # Write temp file for resolver
          with open('/tmp/pattern-request.yaml', 'w') as f:
              yaml.dump(config, f)

          # Run pattern resolver
          result = subprocess.run(
              ['python3', 'scripts/resolve-pattern.py', '/tmp/pattern-request.yaml', '--output', 'json'],
              capture_output=True,
              text=True
          )

          if result.returncode != 0:
              print(f"::error::Pattern resolution failed: {result.stderr}")
              sys.exit(1)

          tfvars = json.loads(result.stdout)

          # Write tfvars for Terraform
          with open('terraform.tfvars.json', 'w') as f:
              json.dump(tfvars, f, indent=2)

          print("Resolved tfvars:")
          print(json.dumps(tfvars, indent=2))

          # Output for subsequent steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"pattern={pattern}\n")
              f.write(f"environment={environment}\n")
              f.write(f"project={project}\n")
              f.write(f"business_unit={business_unit}\n")
              name = config.get('config', {}).get('name', pattern)
              state_key = f"{business_unit}/{environment}/{project}/{pattern}-{name}/terraform.tfstate"
              f.write(f"state_key={state_key}\n")
          PYTHON_SCRIPT

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets[format('AZURE_CLIENT_ID_{0}', steps.resolve.outputs.environment)] }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform workspace
        run: |
          PATTERN="${{ steps.resolve.outputs.pattern }}"
          # Preserve directory structure so ../../modules/ paths work
          mkdir -p terraform-workspace/terraform/patterns
          cp -r "terraform/patterns/$PATTERN" "terraform-workspace/terraform/patterns/$PATTERN"
          cp -r terraform/modules terraform-workspace/terraform/
          cp terraform.tfvars.json "terraform-workspace/terraform/patterns/$PATTERN/"

      - name: Terraform Init
        working-directory: terraform-workspace/terraform/patterns/${{ steps.resolve.outputs.pattern }}
        env:
          ARM_USE_OIDC: true
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets[format('AZURE_CLIENT_ID_{0}', steps.resolve.outputs.environment)] }}
        run: |
          terraform init \
            -backend-config="storage_account_name=${{ env.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.TF_STATE_CONTAINER }}" \
            -backend-config="key=${{ steps.resolve.outputs.state_key }}" \
            -backend-config="use_oidc=true" \
            -backend-config="use_azuread_auth=true"

      - name: Terraform Plan
        working-directory: terraform-workspace/terraform/patterns/${{ steps.resolve.outputs.pattern }}
        env:
          ARM_USE_OIDC: true
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets[format('AZURE_CLIENT_ID_{0}', steps.resolve.outputs.environment)] }}
        run: |
          terraform plan \
            -var-file=terraform.tfvars.json \
            -out=tfplan \
            -no-color

      - name: Terraform Apply
        working-directory: terraform-workspace/terraform/patterns/${{ steps.resolve.outputs.pattern }}
        env:
          ARM_USE_OIDC: true
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets[format('AZURE_CLIENT_ID_{0}', steps.resolve.outputs.environment)] }}
        run: |
          terraform apply -auto-approve tfplan

      - name: Capture Terraform Outputs
        id: outputs
        working-directory: terraform-workspace/terraform/patterns/${{ steps.resolve.outputs.pattern }}
        run: |
          terraform output -json > /tmp/tf-outputs.json
          echo "Terraform outputs:"
          cat /tmp/tf-outputs.json

          # Extract key outputs for the issue body (filter sensitive data)
          python3 << 'PYTHON_SCRIPT'
          import json
          import os

          with open('/tmp/tf-outputs.json') as f:
              outputs = json.load(f)

          # Build a markdown-friendly output summary
          summary_lines = []
          access_info = []

          for key, value in outputs.items():
              val = value.get('value', '')
              sensitive = value.get('sensitive', False)

              if sensitive:
                  summary_lines.append(f"| {key} | *(sensitive - see Key Vault)* |")
              elif key == 'access_info':
                  access_info.append(val)
              elif isinstance(val, dict):
                  for k, v in val.items():
                      summary_lines.append(f"| {key}.{k} | `{v}` |")
              elif isinstance(val, list):
                  summary_lines.append(f"| {key} | `{', '.join(str(v) for v in val)}` |")
              else:
                  summary_lines.append(f"| {key} | `{val}` |")

          with open('/tmp/outputs-summary.md', 'w') as f:
              if summary_lines:
                  f.write("| Output | Value |\n")
                  f.write("|--------|-------|\n")
                  f.write("\n".join(summary_lines))
                  f.write("\n")
              if access_info:
                  f.write("\n### Access Information\n\n")
                  f.write("\n".join(access_info))

          PYTHON_SCRIPT

      - name: Create Job Summary
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Infrastructure Provisioned

          | Property | Value |
          |----------|-------|
          | Request ID | \`${{ steps.request.outputs.request_id }}\` |
          | Source Repository | \`${{ steps.request.outputs.repository }}\` |
          | Commit | \`${{ steps.request.outputs.commit_sha }}\` |
          | Pattern | \`${{ steps.resolve.outputs.pattern }}\` |
          | Project | \`${{ steps.resolve.outputs.project }}\` |
          | Environment | \`${{ steps.resolve.outputs.environment }}\` |

          ### Terraform Outputs
          \`\`\`json
          $(cat /tmp/tf-outputs.json)
          \`\`\`
          EOF

      # =========================================================================
      # SUCCESS: Report back to source repository
      # =========================================================================
      - name: Set Commit Status - Success
        if: success()
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          gh api repos/${{ steps.request.outputs.repository }}/statuses/${{ steps.request.outputs.commit_sha }} \
            -f state=success \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="Infrastructure provisioned successfully" \
            -f context="infrastructure/provision"

      - name: Create Success Issue in Source Repo
        if: success()
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Build issue body
          OUTPUTS_SUMMARY=""
          if [ -f /tmp/outputs-summary.md ]; then
            OUTPUTS_SUMMARY=$(cat /tmp/outputs-summary.md)
          fi

          ISSUE_BODY=$(cat << 'ISSUE_EOF'
          ## ✅ Infrastructure Provisioned Successfully

          Your infrastructure request has been provisioned.

          ### Request Details

          | Property | Value |
          |----------|-------|
          | Pattern | `${{ steps.resolve.outputs.pattern }}` |
          | Project | `${{ steps.resolve.outputs.project }}` |
          | Environment | `${{ steps.resolve.outputs.environment }}` |
          | Business Unit | `${{ steps.resolve.outputs.business_unit }}` |
          | Commit | `${{ steps.request.outputs.commit_sha }}` |

          ### Resources Created

          ISSUE_EOF
          )

          # Append outputs summary
          ISSUE_BODY="${ISSUE_BODY}
          ${OUTPUTS_SUMMARY}

          ### Next Steps

          1. **Request access**: Ask your team lead to add you to the appropriate security group
          2. **Access secrets**: Once added, retrieve secrets from Key Vault:
             \`\`\`bash
             az keyvault secret list --vault-name <vault-name>
             az keyvault secret show --vault-name <vault-name> --name <secret-name>
             \`\`\`
          3. **View provisioning details**: [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### Questions or Issues?

          If you encounter problems, create an issue in the [infrastructure-automation](https://github.com/${{ github.repository }}) repository.

          ---
          *Provisioned by Infrastructure Platform • Request ID: \`${{ steps.request.outputs.request_id }}\`*
          "

          # Create the issue
          gh issue create \
            --repo "${{ steps.request.outputs.repository }}" \
            --title "✅ Infrastructure Provisioned: ${{ steps.resolve.outputs.pattern }} (${{ steps.resolve.outputs.environment }})" \
            --body "$ISSUE_BODY" \
            --label "infrastructure"

      # =========================================================================
      # FAILURE: Report back to source repository
      # =========================================================================
      - name: Set Commit Status - Failure
        if: failure()
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          gh api repos/${{ steps.request.outputs.repository }}/statuses/${{ steps.request.outputs.commit_sha }} \
            -f state=failure \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="Infrastructure provisioning failed" \
            -f context="infrastructure/provision" || true

      - name: Create Failure Issue in Source Repo
        if: failure()
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          ISSUE_BODY=$(cat << 'ISSUE_EOF'
          ## ❌ Infrastructure Provisioning Failed

          Your infrastructure request failed to provision. Please review the error and try again.

          ### Request Details

          | Property | Value |
          |----------|-------|
          | Pattern | `${{ steps.resolve.outputs.pattern }}` |
          | Project | `${{ steps.resolve.outputs.project }}` |
          | Environment | `${{ steps.resolve.outputs.environment }}` |
          | Commit | `${{ steps.request.outputs.commit_sha }}` |

          ### What to do

          1. **View the error**: Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed error messages
          2. **Fix the issue**: Update your `infrastructure.yaml` based on the error
          3. **Retry**: Commit and push to trigger a new provisioning attempt

          ### Common Issues

          - **Invalid pattern configuration**: Check that all required fields are present
          - **Naming conflicts**: Resource names must be unique within Azure
          - **Permission errors**: The service principal may not have required permissions
          - **Quota limits**: Your subscription may have hit resource limits

          ### Need Help?

          Create an issue in the [infrastructure-automation](https://github.com/${{ github.repository }}) repository with:
          - Your `infrastructure.yaml` content
          - The error message from the workflow run

          ---
          *Infrastructure Platform • Request ID: \`${{ steps.request.outputs.request_id }}\`*
          ISSUE_EOF
          )

          # Create the issue
          gh issue create \
            --repo "${{ steps.request.outputs.repository }}" \
            --title "❌ Infrastructure Failed: ${{ steps.resolve.outputs.pattern }} (${{ steps.resolve.outputs.environment }})" \
            --body "$ISSUE_BODY" \
            --label "infrastructure,failed" || true
